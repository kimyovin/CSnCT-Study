프로세스를 메모리에 적재(Fetch)하는 방법은 크게 **연속 메모리 할당 방법**, **비연속(분산) 메모리 할당 방법**이 있다.

# 연속 메모리 할당 방법

메모리에 프로세스를 적재할 때 연속적으로 적재하는 방법

- 초기 컴퓨터 시스템에서 많이 사용하던 방법
- 각 프로그램이 연속된 하나의 블록을 차지하도록 적재한다.
- 직접 배치, 중첩(오버레이), 고정 분할 방법
- 단점
    - 직접 배치, 중첩 : 내부/외부 단편화 문제가 발생할 수 있다.
    - 고정 분할 : 크기가 다른 프로세스를 같은 크기에 메모리를 할당하므로 메모리 낭비

## 단일 프로그래밍 환경에서 연속 메모리 할당

메모리는 운영체제 영역(모니터), 사용자 영역(사용자 프로세스)으로 나눠져있다.

메모리 제어권은 사용자에게 있다.

- 사용자가 주소를 잘못 지정하여 운영체제가 적재된 부분을 침범하면 운영체제가 손상될 수 있다.

    → 따라서 운영체제 영역과 사용자 영역 사이에 **경계(한계) 레지스터**를 두어 사용자 프로그램이 메모리 주소를 참조할 때마다 경계 레지스터를 검사한 후 실행한다.

<p>
  <img src="./imgs/연속%20메모리%20할당/경계%20레지스터.png" width="500">
</p>

- 기준 레지스터 : 가장 작은 물리적 주소를 저장한다. (물리적 주소)
- 경계 레지스터 : 프로그램 영역이 저장되어 있는 크기를 저장한다. (논리적 주소)

사용자 프로그램의 시작 주소는 기준 레지스터 값 이후가 된다.

따라서 기준 레지스터 값이 바뀌면 프로그램을 다시 적재해야한다.

- 해결책1. 사용자 프로그램을 기준 레지스터보다 상위 메모리에 적재하는 것
- 해결책2. 주소 바인딩을 연기한다. 즉, 동적 적재를 한다.

<p>
  <img src="./imgs/연속%20메모리%20할당/기준%20레지스터.png">
</p>

주소 바인딩을 연기하는 기준 레지스터가 필요하다.

기준 레지스터에 있는 값은 사용자 프로세스를 메모리로 보낼 때 생성하는 주소 값에 더한다. 

**단점**

- 한 번에 프로그램 하나만 사용할 수 있다.
- 메모리 효율성이 떨어진다.
- 입출력 작업이 교대로 발생한다면 프로세서의 유휴 상태가 자주 일어나기 때문에 자원 낭비가 심하고 프로세스 스와핑 비용이 많이 든다.

# 다중 프로그래밍 환경에서 연속 메모리 할당

다중 프로그래밍 환경에서는 **고정 분할 방법**과 **가변 분할 방법**으로 연속적으로 메모리를 할당한다.

## 고정 분할 방법

메모리를 여러 개의 **고정된 크기로 분할**하고 분할된 메모리는 프로세스 하나만 실행할 수 있다.

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/고정%20분할%20방법.png" width="700">
</p>

- 물리적 주소는 분할 기준 레지스터(PBR)에 논리적 주소를 더해서 생성한다. (물리적 주소 = PBR + 논리적 주소)
- 논리적 주소가 분할된 메모리 보다 크면 오류 발생
- 내부 단편화가 발생한다.

### 내부 단편화

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/내부%20단편화.png" width="700">
</p>

**(a)** 그림

- 32KB를 1개의10KB, 3개의 4KB 고정된 크기로 메모리를 분할하였다.
- 프로세스 P1을  10KB 사용자 공간에 할당할 때 영역 안 3KB의 남은 공간이 생긴다.
- 분할된 메모리 공간 안에 생긴 남은 공간을 **내부 단편화**라고 한다.

**(b)** 그림

- 프로세스 P1을  4KB 2개 사용자 공간에 할당할 때 영역 안 1KB의 남은 공간이 생긴다.
- 또한 (a)그림과 달리 3개의 프로세스가 할당이 가능하다.

내부 단편화는 스케줄링과 분할 크기에 따라 메모리 낭비가 다르게 발생한다.

### 메모리 보호 방법

여러 프로세스가 메모리에 할당되어있을 경우, 각 프로세스끼리의 영역이 침범당하면 안된다.

따라서 운영체제 영역과 사용자 영역을 구분지을때처럼 **기준 레지스터**와 **경계 레지스터**를 사용한다.

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/고정%20분할_메모리%20보호.png" width="700">
</p>

프로세서에서 사용하는 주소는 기준 레지스터 값(하한 값)보다 크거나 같고

기준 레지스터 값+경계 레지스터 값 (상한 값)보다 작아야 한다.

(a) 그림의 **작업2**

- 작업2의 물리적 주소 하한값이 30040이고 크기가 120900이다.
    - 기준 레지스터 값: 30040, 경계 레지스터 : 120900
    - 사용자 주소 범위는 0~120900으로 논리적 주소인 경계 레지스터보다 작아야 한다.
    - 상한값은 기준 레지스터 + 경계 레지스터 = 30040+120900 = 420940
    - 사용자 주소는 하한 값과 상한 값 사이가 된다.

### 분할 수에 제한을 받는다.

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/고정%20분할_대기%20큐.png" width="700">
</p>

고정 분할 시스템에서 분할된 **메모리 영역**과 **선입선처리 작업 스케줄러**, **대기 큐**가 있다고 하자.

- 5KB 작업1은 6KB에 할당
- 2KB 작업2는 2KB에 할당
- 3KB 작업3은 12KB에 할당
- 7KB 작업4는 작업3이 끝날 때까지 기다려야 한다.

이렇듯 고정 분할 시스템의 성능은 분할 크기와 개수에 영향을 받는다.

다중 프로그래밍의 성능을 향상시키려면 

- **분할 영역 개수와 크기를 적절히 정해야한다.**
- 또한 프로그램 **작업을 어느 영역에 배치하는지 결정하는 작업 스케줄러가 필요하다.**

## 가변 분할 방법

메모리를 각 프로세스가 필요한 만큼 할당하는 방법

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/가변%20분할%20방법.png" width="700">
</p>

- 프로세서가 생성한 논리적 주소는 경계 레지스터보다 크면 오류가 발생한다.
- 운영체제가 메모리의 어느 부분을 사용하고 어느 부분을 사용할 수 있는지 알 수 있는 테이블이 있어야 한다.
- 내부 단편화는 없고 외부 단편화가 발생할 수 있다.
- 사용 가능 공간을 어느 작업에 할당할지 결정하는 방법(배치 정책, Placement policy)으로 **최초 적합**, **최적 적합**, **최악 접합** 방법이 있고 외부 단편화 해결을 위한 **메모리 통합**, **메모리 압축** 방법이 있다.

### 최초 적합(first-fit)

사용 가능한 공간 중 **충분히 큰 첫 번째 공간**에 할당한다.

- (장점) 사용 공간을 빨리 찾을 수 있다.
- (단점) 공간 활용률이 떨어질 수 있다.

### 최적 적합(best-fit)

충분히 큰 **사용 가능 공간 중에서 가장 작은 공간**에 할당한다.

- 사용 가능 공간을 계속 정렬하는 과정이 필요하다.
- (장점) 사용 가능 공간 이용률이 향상된다.
- (단점) 할당하는 시간이 많이 소요될 수 있다.
- (단점) 가장 작은 또 다른 사용 가능 공간을 만들 수도 있다.

### 최악 적합(worst-fit)

가장 큰 사용 공간에 할당한다.

- 사용 가능 공간을 계속 정렬하는 과정이 필요하다.
- (장점) 가장 큰 사용 가능 공간에 할당하기 때문에 메모리 활용 면에서 더 유용하다.

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/배치%20정책%20종류.png" width="900">
</p>

### 메모리 보호 방법

기준 레지스터와 경계 레지스터로 검사를 한다.

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/가변%20분할_메모리%20보호.png" width="700">
</p>

### 외부 단편화 해결책

가변 분할 시스템은 프로세스 크기만큼 메모리 공간을 만들기 때문에 내부 단편화는 일어나지 않는다.

하지만 외부 단편화가 발생할 수 있다.

이에 대한 해결책은 **메모리 통합 방법**과 **메모리 압축 방법**이 있다.

### 메모리 통합 방법

하나의 작업이 끝났을 때 다른 빈 공간과 인접해 있는지 확인하여 하나로 합친다.

-> 인접한 빈 공간을 합쳐 하나의 공간으로 만든다.

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/메모리%20통합%20방법.png" width="700">
</p>

### 메모리 압축 방법

메모리의 빈 부분 공간을 적절히 움직여 사용 가능 공간을 큰 블록 하나로 만든다.

- 대체 정책(Replacement policy)이 **동적**일 때만 가능하다.
    - 프로세스들이 이동하여 기준 레지스터의 변화를 요구하여 새로운 기준 주소를 반영하기 때문
- **실행 시간**에만 가능하다.
- 즉, 메모리 압축은 주소를 동적으로 대체하고 실행 시간에만 가능하다.

<p align="center">
  <img src="./imgs/연속%20메모리%20할당/메모리%20압축%20방법.png" width="500">
</p>

(단점)

- 입축하는 동안 시스템은 모든 일을 중지해야한다.
    → 대화형 시스템에는 적합하지 않다.
- 메모리에 있는 작업들을 이동해야하기 때문에 대체 관련 정보를 액세스 가능한 형태로 보관해야한다.
- 압축 자원을 자주 요구하여 시스템 자원의 소모가 크다.

## 다중 프로그래밍 환경의 버디 시스템

단편화 현상을 해결하는 방법으로 **버디 시스템(buddy system)** 이 탄생했다.

큰 버퍼들을 반복적으로 이등분하여 작은 버퍼를 만든다.

가능할 때마다 인접한 빈 버퍼들을 합치는 과정을 반복한다.

- 유닉스의 커널 메모리 할당이나 병렬 처리 시스템에서만 응용한다.
- 최근 운영체제는 페이징이나 세그먼테이션을 활용한 가상 메모리를 선호한다.
