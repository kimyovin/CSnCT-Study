# 가상 메모리
> Virtual memory

실제 물리적 메모리 용량보다 크기가 큰 프로세스를 실행하기 위해 나온 기술

- 물리적인 메모리 크기의 한계를 넘을 수 있다.

- 프로세스의 필요한 일부분만 적재하여 실행을 한다.

- (장점) 프로세서의 이용률과 처리율 향상

- 프로세스는 가상 주소(논리적 주소)를 사용하고, 메인 메모리는 물리적 주소를 사용한다.
    - `가상 주소` : 프로세스가 참조하는 주소
    - `물리 주소` : 실제 메모리에서 사용하는 주소

- **동적 주소 변환(DAT, Dynamic Address Translation)** 을 실행한다.
    - `DAT` : 가상주소를 물리주소로 매핑하는 작업. 가상메모리에서 가상 주소가 연속적이라고 메인 메모리에서 물리주소가 연속적일 필요는 없다.

<p>
  <img src="https://github.com/triflingness/CSnCT-Study/blob/32b5c2601d2a431ad6a2adc4457ca7d1c81a90f7/OS/imgs/%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5/%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8_%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9_%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB.png" width="500">
</p>

- 프로세스의 일부분이 페이지일 수도 있고 세그먼트일 수 도 있지만 페이지 단위로 많이 사용된다.

# 요구 페이징(Demading Paging)

> 필요한 페이지만 메모리에 적재되는 것

- 페이지 테이블은 해당 페이지가 메인 메모리에 있는 지(유효 페이지인지)를 **Vaild bit**로 나타낸다.
    - `Vaild bit(1)` : 메모리에 적재되어 있다.
    - `Vaild bit(0)` : 메모리에 적재되어 있지 않다. ( = `페이지 부재`)

필요한 페이지가 메모리에 적재되어 있지 않다면, 즉 vaild bit = 0 이면

CPU는 하던 작업을 멈추고 보조기억장치에서 필요한 페이지를 로드한다.

즉, `페이지 부재`가 일어난다.


<p align="center">
  <img src="https://github.com/triflingness/CSnCT-Study/blob/32b5c2601d2a431ad6a2adc4457ca7d1c81a90f7/OS/imgs/%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5/vaild_bit%E1%84%85%E1%85%B3%E1%86%AF_%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%E1%84%92%E1%85%A1%E1%86%AB_%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5_%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF.png" width="700">
</p>

## 페이지 부재(page fault)

프로세스가 메인 메모리에 적재되지 않은 페이지를 액세스하려고 할 때 하드웨어가 제기하는 소프트웨어 트랩

<p align="center">
  <img src="https://github.com/triflingness/CSnCT-Study/blob/32b5c2601d2a431ad6a2adc4457ca7d1c81a90f7/OS/imgs/%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5/%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5_%E1%84%87%E1%85%AE%E1%84%8C%E1%85%A2_%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5_%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC.png" width="700">
</p>

`페이지 부재` 처리는 다음과 같은 과정을 거친다.

1. 프로세스가 가상 주소에 액세스하려 한다.
    1. 프로세스 B를 실행하려고 가상 주소(페이지 번호 :1)에 액세스하려 한다.
2. 프로세스가 필요한 **페이지가 메모리에 적재되어 있는 지 확인**한다.
    1. 페이지 1이 적재되어 있는 지 확인한다.
3. vaild bit가 0이면 trap이 발생하여 제어권을 넘겨받은 운영체제가 해당 페이지를 가져오는 조치를 한다.
4. 메모리에서 빈 프레임 중 하나를 선택한다.
5. 할당된 프레임에 요구된 페이지를 디스크에서 가져온다. 그동안 프로세서는 다른 프로세스의 디스크 동작을 스케줄링한다.
6. 해당 페이지를 디스크에서 메모리로 가져온다.
7. **페이지 테이블의 vaild bit를 업데이트**하여 요구된 페이지가 메모리에 적재됐음을 알려준다.
8. 주소 트랩으로 인터럽트된 명령어들을 다시 시작한다.

페이지 부재로 인해 몇가지 단점이 생긴다.

- 개별 프로그램들은 페이지에 처음 액세스할 때 약간의 지연이 발생한다.
- 메모리 액세스 시간 예측이 어렵다.
    - 적재되어있지 않으면 디스크에 접근해야하기 때문에 항상 일정하지 않다.
- 페이지 교체 알고리즘을 포함하는 메모리 관계가 복잡해진다.
    - 메모리에 빈 프레임이 없으면 페이지 교체가 필요하다.

## 페이지 교체(page replacement)

> = 페이지 대치

메인 메모리 내에 프레임이 가득 찼을 경우, 페이지 성능을 높이기 위해 

페이지 부재가 일어났을 때

메인 메모리에 있으면서 **사용하지 않는 페이지를 없애고 새로운 페이지로 교체한다.**

<p align="center">
  <img src="https://github.com/triflingness/CSnCT-Study/blob/32b5c2601d2a431ad6a2adc4457ca7d1c81a90f7/OS/imgs/%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5/%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5_%E1%84%83%E1%85%A2%E1%84%8E%E1%85%B5_%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC.png" width="700">
</p>

1. 빈 프레임이 없으면, 페이지 대치 알고리즘을 사용하여 `희생자 프레임`을 선정한다.
    1. victim page M을 선정하여 프레임읠 내용을 디스크에 저장(swap-out)하여 프레임을 비운다.
2. 페이지 테이블에서 **`희생자 페이지`의 vaild bit를 업데이트** 한다.
    1. M의 vaild bit를 0으로 바꾼다.
3. 프로세스가 요구한 페이지를 디스크에서 읽어 프레임에 저장한다.
    1. 요구한 페이지 A를 메모리에 적재한다.
4. 페이지 테이블에서 **요구한 페이지의 vaild bit를 업데이트**한다.

이때 다시 사용될 프레임을 `희생자 프레임`으로 선택하면 입출력 시간이 증가된다.

따라서 어떤 프레임을 희생자로 선택할지 정하는 **페이지 대치 알고리즘**은 시스템 성능 측정할 때 중요한 요소가 된다.
