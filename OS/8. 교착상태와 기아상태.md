# 교착 상태(deadlock)

**상호 배제**에 의해 나타나는 문제점

- 다중 프로그래밍 시스템에서 프로세스가 결코 일어나지 않을 이벤트를 기다리는 상태
- 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상
- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태

## 교착 상태의 필요 조건(Necessary Conditions)

4가지 조건이 모두 만족해야 교착상태가 발생할 수 있다.

순환 대기는 상호 배제, 점유와 대기, 비선점 조건을 모두 만족할 때 발생할 수 있는 결과이다. '순환 대기'를 어떻게 해결할 것인가에 초점을 맞추는 것이 타당하다.

1. **상호 배제 (Mutual Exclusion)**: 한 번에 프로세스 하나만 해당 자원을 사용할 수 있어야 한다.
2. **점유와 대기 (Hold and wait)**: 최소한 하나의 **자원을 점유하고 있으면서** 다른 프로세스에 할당된 **자원을 얻으려고 기다리는 프로세스**가 있어야 한다.
3. **비선점 (Non-preemption)**: 자원은 강제로 빼앗을 수 없고 자원을 점유하고 있는 프로세스가 끝내야 해제된다.
4. **순환(환형) 대기 (Circular wait)**: 상대방이 가진 자원을 서로 대기하는 상태

<p align="center">
  <img src="https://github.com/triflingness/CSnCT-Study/blob/e1af1a00362ebd3e4cc0f11c79352ea553740d42/OS/imgs/8.%20%E1%84%80%E1%85%AD%E1%84%8E%E1%85%A1%E1%86%A8%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%E1%84%8B%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%8B%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2/%E1%84%89%E1%85%AE%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20%E1%84%83%E1%85%A2%E1%84%80%E1%85%B5.png">
</p>

## 교착 상태의 표현 : 자원 할당 그래프

교착 상태는 시스템 자원 할당 그래프인 방향 그래프로 표현할 수 있다.

- 프로세스 집합 P = {P1, P2, ..., Pn}
- 자원 집합 R = {R1, R2, ..., Rn}
- 프로세스 Pi가 자원 Rj를 요청 : Pi → Rj
- 자원 Rj를 프로세스 Pi에 할당 : Rj → Pi

<p align="center">
  <img src="https://github.com/triflingness/CSnCT-Study/blob/e1af1a00362ebd3e4cc0f11c79352ea553740d42/OS/imgs/8.%20%E1%84%80%E1%85%AD%E1%84%8E%E1%85%A1%E1%86%A8%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%E1%84%8B%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%8B%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2/%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%20%E1%84%92%E1%85%A1%E1%86%AF%E1%84%83%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3.png">
</p>

왼쪽 그래프에서는 사이클이 2개가 있다. 따라서 프로세스 P1, P2, P3는 교착 상태이다.

- 1) P1 → R1 → P2 → R3 → P3 → R2 → P1
    - 프로세스 P3은 자원 R2를 얻으려고 프로세스 P1이나 프로세스 P2가 자원 R2를 해제할 때까지 기다린다.
- 2) P2 → R3 → P3 → R2 → P2
    - 프로세스 P2는 프로세스 P3이 점유한 자원 R3을 기다린다.

오른쪽 그래프는 프로세스 P4가 자원 R2를 해제할 수 있기 때문에 교착 상태가 아닌다. 

이렇듯 사이클을 가진 그래프라고 교착 상태인 것은 아니다.

# 기아 상태

프로세스의 우선순위가 낮아 원하는 자원을 할당받지 못하는 상태

- 교착 상태를 예방하려고 자원을 할당할 때 발생하는 결과
- 교착 상태는 자원을 자유롭게 할당한 결과(자원 부족)
- 기아 상태는 결코 사용할 수 없는 자원을 계속 기다리는 결과(교착상태)를 예방하려고 자원을 할당할 때 발생(기다림)하는 결과
- ex) 식사하는 철학자 문제

<details>
<summary>식사하는 철학자 보기</summary>
<div markdown="1">       

  ### 문제 설명

    다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 포크가 하나씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다. 철학자가 스파게티를 먹기 위해서는 양 옆의 포크를 동시에 들어야 한다. 

    ### 문제점

    이때 각각의 철학자가 왼쪽의 포크를 들고 그 다음 오른쪽의 포크를 들어서 스파게티를 먹는 알고리즘을 가지고 있으면, 다섯 철학자는 동시에 왼쪽의 포크를 들 수 있으나 오른쪽의 포크는 이미 가져가진 상태이기 때문에 다섯 명 모두가 무한정 서로를 기다리는 교착 상태에 빠지게 될 수 있다.

    또한 어떤 경우에는 동시에 양쪽 포크를 집을 수 없어 식사를 하지 못하는 기아 상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

    ### 해결책

    각각의 철학자를 P1, P2, P3, P4, P5 라고 하고, 각 철학자의 왼쪽 포크를 fork1, fork2, fork3, fork4, fork5 라고 하자. 

    P5를 제외한 네 명은 먼저 fork[n]를 집은 후 fork[n+1] 를 집는 방식을 취한다. 그리고 P5는 이와 반대로, fork1를 먼저 집은 후 fork5 를 집는다. 이것은 원래 방식의 대칭성을 제거하고, 따라서 교착 상태를 막을 수 있다.

</div>
</details>
    
