# 은행원 알고리즘
> 교착 상태의 회피 알고리즘

교착 상태가 일어날 가능성이 있는 지 없는 지를 검사하여 안정 상태를 유지할 수 있는 요구만 수락하고 불안정 상태를 초래할 프로세스의 요구는 나중에 만족될 수 있을 때까지 거절하여 교착 상태를 회피한다.

- 다익스트라가 제안한 기법
- 은행이 최소한 한 명에게 대출해줄 수 있는 금액을 항상 보유하고 있어야한다는 개념에서 나온 것이다.
- 자원을 할당하기 전에 미리 결정된 모든 자원의 최대 가능한 할당량을 시뮬레이션하여 안전 여부를 검사한다.

## 안정 상태와 불안정 상태

시스템의 상태는 **안정 상태**와 **불안정 상태**로 나눌 수 있다.

### 안정 상태

교착 상태가 일어날 가능성이 없는 상태

- 프로세스가 요구한 만큼 자원 할당 가능

### 불안정 상태

교착 상태가 일어날 가능성이 있는 상태

- 불안정 상태가 된다고 다 교착 상태인 것은 아니다. (불안정 상태 ≠ 교착 상태)
- 교착 상태 ⊂ 불안정 상태
- 프로세스가 요구한 만큼 자원 할당 불가능

## 은행원 알고리즘(Banker's algorithm)

여기서 n은 프로세스 수, m은 자원의 수이다.

### 필요한 자료 구조

- `Available` : 자원의 각 형태별로 사용 가능한 자원 수 = 시스템이 빌려 줄 수 있는 자원의 양
    - 크기가 m인 벡터
    - `Available[j]=k` 이면, **자원 Rj를 k개 사용할 수 있다**는 의미

- `Max` : 각 프로세스가 자원의 최대 요구량
    - n x m 행렬
    - `Max[i, j] = k` 이면, **프로세스 Pi는 자원 Rj를 최대 k 개까지 요청할 수 있다.**

- `Allocation` : 현재 각 프로세스에 할당되어 있는 각 형태의 자원 수 = 현재 프로세스가 할당받은 자원 수
    - n x m 행렬
    - `Allocation[i, j] = k` 이면, **프로세스 Pi는 자원 Rj를 최대 k 개 할당받고 있다**는 의미

- `Need` : 각 프로세스에 남아 있는 자원 요청량 = 각 프로세스가 추가적으로 요구할 자원의 수
    - n x m 행렬
    - `Need[i, j] = Max[i, j] - Allocation[i, j]`
    - `Need[i, j] = k` 이면, **프로세스 Pi는 남은 작업을 종료하기 위해 자원 Rj를 k 개 더 요청한다**는 의미

### 은행원 알고리즘

`Request(i)`는 프로세스 Pi를 요청하는 벡터라 하자.

`Request(i)[j] = k` 이면, 프로세스 Pi는 자원 Rj를 k 개 요청한다는 의미이다.

프로세스 Pi가 자원을 요청하면 다음 동작이 일어난다.

```
1 단계 : Request(i) ≤ Need(i) 이면 // 즉, 요청한 자원의 수가 작업을 끝내는 데 필요한 수보다 작거나 같으면
				2단계로 이동하고, 그렇지 않으면 프로세스가 최대 요청치를 초과하기 때문에 오류 상태가 된다.
2 단계 : Request(i) ≤ Available 이면 // 즉, 요청한 수가 시스템이 빌려줄 수 있는 자원의 수보다 작거나 같으면(빌려줄 수 있으면)
				3단계로 이동하고, 그렇지 않으면 자원이 부족하기 때문에 프로세스Pi는 대기한다.
3 단계 : 시스템은 상태를 다음과 같이 수정하여 요청된 자원을 프로세스 Pi에 할당한다.
				Available = Available - Request(i);
				Allocation(i) = Allocation(i) + Request(i);
				Need(i) = Need(i) - Request(i);
```

불안정 상태라면 `P(i)`는 `Requesst(i)`를 대기하고 이전 자원 할당의 상태로 복귀한다.

### 안전 알고리즘

시스템이 안정 상태인지, 불안정 상태인지 검사한다.

```
1 단계 : Work, Finish를 각각 길이가 m과 n인 벡터라고 하자. 
				Work = Available, Finish[i] = false (i = 1, 2, ..., n) 이 되도록 초기화한다.
2 단계 : 다음을 만족하는 i 값을 찾는다. i 값이 없으면 4단계로 이동한다.
				i) Finish[i] == false 
				ii) Need(i) ≤ Work // 즉, 프로세스 Pi가 필요한 자원이 시스템이 현재 가지고 있는 자원보다 적거나 같으면 안정적이다.
3 단계 : 다음을 수행하고 2단계로 이동한다.
				Work = Work + Allocation
				Finish[i] = true
4 단계 : 모든 i에 대하여 Finish[i] == true 이면 시스템은 안정 상태이다.
```

### 예시1

현재 시스템의 상태가 다음과 같다.

<p>
  <img src="./imgs/은행원%20알고리즘/ex1.png">
</p>

이 시스템은 현재안정 상태이다.

현재 Available 자원은 (1, 2, 2, 2)이다.

P0부터 순서대로 탐색을 해보자.

각 프로세스의 Request 는 Need와 같다고 하자.

**Step 0**

Work = Availble, Finish[i] = false 로 초기화 해놓는다.

**Step 1** 

`Need[0] (1, 2, 0, 3) ≤ Work (1, 2, 2, 2)` 거짓이므로 P0에게 할당할 수 없다.

`Need[1] (0, 1, 3, 1) ≤ Work (1, 2, 2, 2)` 거짓이므로 P1에게 할당할 수 없다.

`Need[2] (1, 1, 0, 2) ≤ Work (1, 2, 2, 2)` 참이므로 P2에게 할당할 수 있다.

프로세스 P2는 작업을 끝내고 자원을 반납한다.

`Work = (0, 1, 2, 0) + (5, 1, 0, 5) = (5, 2, 2, 5)`

**Step2**

안정 상태를 확인한다.

모든 Need ≤ Work (5, 2, 2, 5) 이므로 시스템은 안정상태이다.

다시 Step 1 으로 돌아가 반복한다.

위의 과정을 나아가면 시스템이 안정상태로 `P2 → P0 → P4 → P1 → P3` 순서로 작업을 한다.

### 예시2

다른 케이스로 프로세스 P1이 Request(1) = (0, 1, 0, 1)을 먼저 요청했다고 가정하자.

**Step1.** `Request(0, 1, 0, 1) ≤ Available(1, 2, 2, 2)` 이므로 자원을 줄 수 있다.

**Step2.** 이제, 안전 알고리즘을 적용해보자.

<p>
  <img src="./imgs/은행원%20알고리즘/ex2.png">
</p>

`Need(i) ≤ Work (1, 1, 2, 1)` 을 만족하는 i를 찾을 수 없다. 모든 프로세스가 조건을 만족하지 않는다.

또한 모든 i 에 대한 `Finish[i] == false`이므로 불완전 상태이다.

따라서 프로세스 P1의 자원 요청(0, 1, 0, 1)을 허용할 수 없다.

### 정리

은행원 알고리즘은 먼저 프로세스의 자원 요청을 수락했을 때 시스템의 안정상태 유무를 확인한 뒤 자원을 할당해준다.

안정 상태를 확인하여 교착 상태가 일어날 가능성이 있으면 작업을 하지 않음으로써 회피할 수 있다.

하지만 다음과 같은 단점이 있다.

### 단점

- 항상 일정하게 남아 있는 자원 수를 파악하기 어렵다.

- 다중 프로그래밍 시스템에서는 사용자 수가 항상 변한다.

- 시스템 과부하가 증가한다.

- 프로세스는 자원을 보유한 상태로 끝낼 수 없다. 시스템에서는 이보다 더 강력한 보장이 필요하다.

- 자원 할당 방법이 점점 동적으로 변하면서 사용자의 최대 필요량을 파악하기 어렵다.

- 항상 불안정 상태를 방지해야 하므로 자원 이용도가 낮다.

---

Q. 은행원 알고리즘(Banker Algorithm) 에 대해 설명하세요.

A.  데드락을 처리하기 위한 방법 중 **회피에 해당**하는 알고리즘입니다. 데드락에 빠질 수 있는 상태를 불안전 상태, 데드락에 빠질 수 없는 상태를 안전 상태 라고 가정했을 때, 운영체제는 이러한 안전 상태인 경우에만 요청을 허락하여 자원을 할당해주고, 나머지 요구들은 안전 상태가 될 때 까지 계속 거절하는 알고리즘입니다.

즉, **은행원 알고리즘**은 은행은 **최소한 한 명에게 대출해줄 수 있는 돈을 가지고 있어야 한다**는 뜻에서 나왔으며, 바꿔말하면 **운영체제가 최소한 하나의 프로세스가 일을 수행할 수 있는 경우에만 요청을 허락하여 시스템의 자원을 할당해주는 것**과 같습니다.

출처: [https://maivve.tistory.com/270](https://maivve.tistory.com/270)
