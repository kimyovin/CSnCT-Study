### **[적재 정책(Fetch policy)](https://github.com/triflingness/CSnCT-Study/blob/main/OS/메모리%20관련%20용어.md#적재-정책fetch-policy)**

프로세스를 디스크에서 메모리로 적재시키는 타이밍을 결정하는 정책

- **요구 적재** : 요청이 들어왔을 때 프로세스를 메모리에 적재하는 방법
    - [요구 페이징(Demading Paging)](https://github.com/triflingness/CSnCT-Study/blob/main/OS/가상%20메모리.md#요구-페이징demading-paging)
- **예상 적재** : 시스템의 요청을 예측하여 미리 메모리에 적재하는 방법
    - 프리페이징(Prepaging)

# 프리페이징

> prepaging

프로세스의 필요한 **모든 페이지를 사전에 메모리에 적재**시키는 방법

- (장점) 입출력을 여러번 수행하는 요구 페이징보다 성능이 좋다.

- (단점) 사용할 페이지 예상이 틀렸을 경우, 입출력 시간과 메모리 낭비로 이어진다.
    - 요구 페이징보다 성능이 떨어지기도 한다.

# 교체 범위

페이지 교체의 범위에 따라 즉, 희생할 페이지 선정의 범위에 따라

**전역 교체**, **지역 교체**로 나눌 수 있다.

## 전역 교체

프로세스가 교체할 프레임을 다른 프로세스에서 획득한다.

→ **전체 프레임을 대상으로** 페이지 교체 알고리즘이 적용된다.

- ex. 리눅스 교체 전략

### 사용하는 이유

대부분 시스템은 개별 프로세스보다 전체적인 시스템의 성능을 중요시하고

최소한의 오버헤드로 쉽게 구현이 가능하여 지역 교체보다 대형 시스템에서 더 효율적이다.

- 하나의 프로세스가 더 많은 메모리가 필요할 수 있다.
- 프로세스의 워킹 셋을 추측할 수 있다.
- 대기 프로세스가 점유한 메모리를 다른 프로세스가 사용 가능하다.

## 지역 교체

프로세스가 교체할 프레임을 자신의 페이지에서 획득한다.

→ **현재 실행 중인 프로세스의 프레임을 대상으로** 페이지 교체 알고리즘이 적용된다.

- 각 프로세스마다 페이지 수가 고정으로 할당된다.
- 프로세스의 중요도에 따라 할당 크기를 조절하여 성능을 향상시킨다.
- 따라서 서로 경쟁하지 않고 독립적으로 페이지 부재를 처리한다.
- ex. 윈도우 XP 교체 전략

<p align="center">
  <img src="https://github.com/triflingness/CSnCT-Study/blob/779d7273a394676953405e1fe82c7362d8ebb12a/OS/imgs/%ED%94%84%EB%A6%AC%ED%8E%98%EC%9D%B4%EC%A7%95%EA%B3%BC%20%EA%B5%90%EC%B2%B4%20%EB%B2%94%EC%9C%84/%EA%B5%90%EC%B2%B4%20%EB%B2%94%EC%9C%84.png" width="700">
</p>

새로운 프로세스 `A6`이 적재되어야하는 상황일 때,

- **전역 대치의 경우**, 교체 알고리즘에 따라 모든 페이지의 우선순위를 가진다.

    전역 대치는 모든 페이지를 대상으로 순서가 `2`인 `B3`이 희생 페이지가 된다.

- **지역 대치의 경우**, 현재 프로세스의 우선순위를 가져 순서가 `3`인 `A5`가 희생 페이지가 된다.
