## 병행 프로세스 (Concurrent Process)

운영체제가 프로세서를 빠르게 전환하여 프로세서 시간을 나눠 `마치 프로세스 여러 개를 동시에 실행하는 것처럼` 보이게 하는 프로세스

* 병행 프로세스는 **독립 프로세스**, **협력 프로세스**로 구분된다.

### 독립 프로세스

> 단일 처리 시스템에서 서로 **독립적**으로 작업을 수행하는 프로세스

- 다른 프로세스에 영향을 받지 않고, 데이터를 공유하지 않는 완전 독립적인 프로세스

### 협력 프로세스

> **다른 프로세스와 협력**하면서 특정 기능을 수행하는 **비동기적 병행 프로세스**

- **다른 프로세스에 영향을 받으며** 데이터를 공유하는 비동기적 병행 프로세스

- 상호작용하며 특정 기능을 수행하는 비동기적 프로세스

- 컴퓨터 자원의 효율성 ↑, 계산속도 ↑, 모듈적 구성 강화, 동시에 여러 작업 수행

- 프로세스가 협력할 경우, **통신을 위한 수단**과 **동기화**가 필요하다.

```
- 협력적 수행 방식의 구분

    - 비동기적 수행 : 프로세스들 간에 정교한 협력을 통해서만 어떤 기능을 수행
    - 동기적 수행 :프로세스 동기화 (Process Synchronization)
        - 여러 독립프로세스 간에 처리 순서를 결정하는 것
        - 즉, 여러프로세스 간 협력시, 누가 먼저 작업할 지, 언제 끝날 지 등을 알려주는 것
        - 또한, 공유데이터에 대한 올바른 공유/접근/조작할 수 있도록 해야 함
```

**병행성**은 여러 프로세스를 이용하여 작업을 수행하는 것으로 `프로세서 간의 충돌`을 해결해야한다.

## 상호 배제 (Mutual Exclusion, Mutex)

- 병행 프로세스에서 **프로세스 하나가 공유 자원을 사용할 때** **다른 프로세스들이 접근할 수 없도록** 하는 방법

- 즉, 공유 자원에 있는 데이터에 접근하는 다른 프로세스를 실행중인 프로세스가 **해당 데이터에 접근할 수 없게 하는 것**

  → 단순 읽기 연산은 동시에 접근해도 괜찮다.

- 상호배제는 **동기화의 한 형태**이다.

## **동기화 (Process Synchronization)**

- 공유 자원을 동시에 사용하지 못하게 실행을 제어하는 방법

- 즉, 프로세스가 어떤 자원을 사용할 때, 다른 프로세스가 해당 자원을 사용하지 못하도록 제어하는 것!

- **상호배제를 보장**하지만, **교착 상태**와 **기아 상태**가 생길 수 있다.


  ```
  ‣ 교착 상태(deadlock) : 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태

  ‣ 기아 상태(starvation) : 프로세스가 끊임없이 필요한 컴퓨터 자원을 가져오지 못하는 상황
  ```
## 임계 영역

- **임계 자원 (Critical Resource)**
    - 동시에 사용할 수 없는 **공유 자원**
    - 즉, 공유 메모리.
- **임계 영역 (Critical Section)**
    - 임계 자원에 접근하고 실행하는  코드 부분

<p>
  <img src="https://github.com/triflingness/CSnCT-Study/blob/1bbae8eb7621ddaf747b959188b64262848114fc/OS/imgs/5.%20%EB%B3%91%ED%96%89%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/%EC%9E%84%EA%B3%84%20%EC%98%81%EC%97%AD.png">
</p>

### 임계 영역의 조건 (3가지)

- **상호 배제(Mutual Exclusion)** : 어떤 프로세스가 임계 영역에서 작업 중이면 다른 프로세스는 임계 영역으로 들어갈 수 없다.

- **진행(Progress)** : 임계 영역에 프로세스가 없는 상태에서 어떤 프로세스가 들어갈지 적절히 결정해야한다.

- **한정 대기(Bounded Waiting)** : 다른 프로세스가 임계 영역을 무한정 기다리는 상황을 방지하려면 임계 영역에 한 번 들어갔던 프로세스는 다음에 임계 영역에 다시 들어갈 때 제한을 둔다.

<p align="center">
  <img src="https://github.com/triflingness/CSnCT-Study/blob/1bbae8eb7621ddaf747b959188b64262848114fc/OS/imgs/5.%20%EB%B3%91%ED%96%89%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/%EC%9E%84%EA%B3%84%20%EC%98%81%EC%97%AD%EC%9D%84%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%83%81%ED%98%B8%EB%B0%B0%EC%A0%9C.png">
</p>

## 경쟁 상태 (Race Condition)

여러 프로세스가 **동시에** **공유 데이터에 접근할 때** **접근 순서에 따라** **실행 결과가 달라지는 상황**

→ '프로세스들이 경쟁 상태에 있다.'

- 공유 데이터의 결과를 보장할 수 없는 상황

<p>
  <img src="https://github.com/triflingness/CSnCT-Study/blob/1bbae8eb7621ddaf747b959188b64262848114fc/OS/imgs/5.%20%EB%B3%91%ED%96%89%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/%EA%B2%BD%EC%9F%81%20%EC%83%81%ED%83%9C.png" width="800">
</p>

**경쟁 상태 해결 방법**

- 병행 프로세스들을 **동기화** 해야한다.

- 동기화하는 방법은? 
  - **임계 영역을 이용한 상호 배제**로 구현!

- 즉, 공유 변수인 counter 연산을 하는 부분을 임계 영역으로 설정하여 다른 프로세스가 접근할 수 없도록 한다.
