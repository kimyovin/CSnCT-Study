Pipeline Hazard
===================

### Hazard란?
- 명령어 실행 지속이 불가하여 지정된 클럭에서 수행되는 파이프라인이 지연, 중지되는 현상
- 파이프라인의 속도가 저하되는 현상
- 해저드의 원인이 사라질 때까지 파이프라인에 명령어 투입을 멈추는 것을 __파이프라인 중지(Pipeline stall)__ 또는 __파이프라인 버블(Pipeline bubble)__ 이라고 함(해당 명령어는 NOP 명령어(No-operation))
> 파이프라인 구조는 선행 명령어와 후행 명령어가 중첩되어 실행되기 때문에 명령어나 데이터가 준비되지 않아서 파이프라인을 멈춰야 하거나 새로운 명령어를 파이프라인에 투입할 경우 잘못된 결과가 초래되는 모든 상황이나 조건

<img>

### Pipeline Hazard의 종류
__1. 구조적 해저드(Structural hazard)__
- 자원의 충돌로 여러 명령이 동시 수행될 때 발생
- 하나의 자원을 여러 명령이 동시에 수행되려고 할 때 발생
- 파이프라인에서 실행 중인 2개 이상의 명령어가 동일한 하드웨어 자원을 동시에 요구할 때 발생
- 하드웨어 자원이 부족할 때에도 나타나기에 자원 해저드(Resource hazard)라고도 함

  <해결방법>
  1. 하드웨어 아키텍처: 메모리에서 데이터 영역과 명령어 영역을 분리하여 동시에 처리할 수 있도록 한다
  2. 하드웨어 자원을 추가한다
  3. 파이프라인 버블(NOP 명령어 삽입): 해당 기능을 사용할 수 있을 때까지 지연시킨다
  
  
  
__2. 데이터 해저드(Data hazard)__
- 데이터의 가용성에 대한 지연으로 발생
- 명령어들의 결과값 의존성에 의해 이전 명령 수행 완료 시까지 다음 명령어의 실행 연기
- 연산할 데이터가 준비되지 않아 파이프라인을 멈춰야하는 모든 상황이나 조건
- 이전 명령어에서 레지스터의 값을 바꾸기 전에 후속 명령어가 그 값을 필요로 하는 경우, 데이터 의존성이 있는 경우 발생
- 데이터 종속(Data dependency): 선행 명령어가 사용하는 데이터와 후행 명령어가 사용하는 데이터 사이의 종속 관계

|유형|발생 이유|발생 경우|
|-|-|:-:|
|RAW (read after write)|쓰기 동작이 완료되기 전에 다음 명령어의 읽기 수행 시 발생|선행 명령어가 데이터를 쓰기 전에 후행 명령어가 먼저 데이터를 읽는 경우|
|WAR (write after read)|읽기 동작이 완료되기 전에 다음 명령어의 쓰기 수행 시 발생|선행 명령어가 데이터를 읽기 전에 후행 명령어가 먼저 데이터를 갱신하는 경우|
|WAW (write after write)|두 명령어가 같은 위치에 쓰기 수행 시 완료되는 동작 순서가 바뀔 때 발생|선행 명령어가 데이터를 갱신하기 전에 후행 명령어가 먼저 갱신하는 경우|

        > RAR (read after after)은 프로세서의 상태를 변화시키지 않기 때문에 무의미하다.


  <해결방법>
   1. 전방 전달(Forwarding) 
    - 별도의 하드웨어를 추가하여 정상적으로 얻을 수 없는 값을 내부 자원으로부터 일찍 받음
    - 주로 발생하는 데이터 해저드는 RAW 해저드임, RAW 해저드의 영향을 줄이기 위해 결과를 생성하는 파이프의 출력과 결과를 사용하는 파이프의 입력을 연결하는 별도의 경로(MUX)를 추가함
   
    > MUX는 Multiplexer으로 여러 아날로그 또는 디지털 입력 신호중 하나를 선택하여 선택된 입력을 하나의 라인에 전달하는 장치이다.
  
   2. Compiler Scheduling: 하드웨어를 수정하지 않고 컴파일러와 어셈블러만을 이용해서 소프트웨어만을 수정하는 방법
    - 파이프라인 버블(NOP 명령어 삽입): 하위파이프라인 실행 중단
    - 명령어 재배치: 데이터 의존 발생 시 실행 순서 변경

__3. 명령어 해저드(Instruction hazard)__
- 명령어의 가용성에 대한 지연으로 발생
- 명령어의 실행 순서를 변경하는 Branch, Jump 등 분기 명령에 의해 발생하여 처리된 명령 무효화
- 실행할 명령어가 결정되지 않았거나 준비되지 않아서 파이프라인을 멈춰야하는 상황이나 조건
- 분기 명령어가 나왔을 때 다음 명령어가 무엇이 될지 모르니 파이프라인에 집어넣을 수 없는 문제
- 파이프라인 명령어(instruction) 실행에 영향을 줌
- 주로 분기 명령어에 의해 발생하기 때문에 __분기 해저드(Branch hazard)__ 또는 __제어 해저드(Control hazard)__ 라고 함
- 캐시 실패(Cache miss)가 명령어 인출 시에도 발생
  > 메인 메모리에서 명령어를 가져와야 하는데 메인 메모리는 캐시 메모리보다 매우 느려 파이프라인에 새로운 명령어를 투입하려면 하나 이상의 사이클을 기다려야한다. 즉, 명령어가 준비되지 않아 파이프라인을 한 사이클 이상 멈춰야 한다.
  
  
  <해결 방법>
  1. 분기 예측(Branch prediction): 분기 명령어의 분기 여부를 예측함으로써 분기 명령어 다음에 수행될 명령어를 미리 파악하는 방법
     - 정적 예측(Static branch prediction): 컴파일러를 이용해 분기 여부를 예측함, 예측이 잘 못 되었을때 투입된 명령어를 취소하여 원래대로 회복함
      - never branch, not taken: 분기가 발생하지 않는다고 가정, 조건 분기 명령어의 조건이 거짓으로 판정되어 다음 명령어를 실행하는 경우
      - always branch, taken: 분기가 발생한다고 가정, 조건 분기 명령어의 조건이 참으로 판정되어 분기 목적지로 이동하는 경우
      - predict by opcode: 연산 코드에 근거해서 분기 예측 
      - 위의 방법들 중 하나를 예측하여 실행하기에, 실행 결과를 갱신하지 않아 원상태 복구가 빠름
      - 예측 성공 시 실행 결과 생신, 실패 시 여측결과를 버리고 원위치로 복구
     - 동적 예측(Dynamic branch prediction): 분기 역사(Branch history)를 참조하여 분기 여부를 예측함
      - 분기 역사: 분기 명령어의 사전 실행 결과
  
  2. 지연 분기(Delayed branch): 분기 명령어와 관계없는 명령어로 지연 슬롯을 채움
     - 손실되는 클럭 동안 프로그램에 영향이 없는 다른 명령 수행
     - 지연 슬롯: 분기명령어에 의해 낭비되는 사이클만큼의 파이프 수
     - 지연 슬롯에 채워질 명령어를 찾는 것은 컴파일러
     - 해당 방법은 반복문일 경우 매우 유용함
     - 분기될 때 반복문 제어를 위한 분기 명령어의 다음 명령어를 실행하고 분기되지 않을 때 취소하면 됨
 
  3. 파이프라인 지연(Pipeline stall): 분기 방향이 결정될 때까지 지연함






